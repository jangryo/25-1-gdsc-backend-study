# 고급 백엔드 스터디 9주차

## Recovery

데이터베이스 시스템은 여러 하드웨어 및 소프트웨어 계층 위에 구축되며, 이러한 계층들은 각자 안정성과 신뢰성 문제를 가질 수 있다. 데이터베이스 시스템 자체뿐만 아니라 그 하부의 소프트웨어 및 하드웨어 구성 요소들도 실패할 수 있다. 데이터베이스 구현자는 이러한 실패 시나리오를 고려하여, "기록되었다"고 약속된 데이터가 실제로 기록되도록 보장해야 한다.

- 쓰기 전 로그(Write-Ahead Log, WAL)란?
    - 충돌 및 트랜잭션 복구를 위해 사용되는 추가 전용(append-only)의 디스크 상 보조 구조체이다.
    - 페이지 캐시는 페이지 내용의 변경 사항을 메모리에서 버퍼링할 수 있도록 해준다.
    - 캐시된 내용이 디스크에 플러시 되기 전까지, 작업 내역을 보존하는 디스크 상의 유일한 사본은 WAL에 저장된다.
    - PostgreSQL, MySQL 등 많은 데이터베이스 시스템들이 추가 전용 WAL을 사용한다.

- 쓰기 전 로그의 주요 기능:
    - 페이지 캐시가 디스크 상 페이지에 대한 업데이트를 버퍼링하는 동안, 데이터베이스 시스템 전체 맥락에서의 내구성(durability) 의미를 보장
    - 영구 저장소에 작업을 먼저 기록하고, 관련 페이지의 캐시 사본이 디스크에 동기화될 때까지 로그를 유지
    - 시스템 충돌 시, 손실된 메모리 내 변경 사항을 로그에서 복원 가능

- 트랜잭션 처리에서의 역할:
    - WAL은 데이터가 영구 저장소에 안전하게 도달할 수 있도록 보장
    - 충돌 발생 시에도 사용 가능하게 한다.
    - 커밋되지 않은 데이터는 로그에서 재실행
    - 충돌 전의 데이터베이스 상태가 완전히 복구

- ARIES(Algorithm for Recovery and Isolation Exploiting Semantics):
    - 이러한 기능들을 구현하여 널리 사용되고 있는 최신 복구 알고리즘

- PostgreSQL과 fsync()의 관계:
    - PostgreSQL은 WAL 기반으로 체크포인트 시 디스크 플러시를 수행
    - 이를 위해 fsync()를 호출하여 커널 페이지를 디스크에 동기화
    - 운영체제 레벨의 문제:
        - 리눅스는 fsync() 호출 후에도 I/O 오류 시 dirty flag를 해제
        - 오류 발생 여부는 이미 열린 파일 디스크립터에만 반영됨
            - 즉, 나중에 연 디스크립터로 호출한 fsync()는 이전 오류를 감지 못한다.
    - PostgreSQL의 체크포인터 한계:
        - 모든 파일을 항상 열어두지 않는다. -> 오류를 놓칠 수 있다.
        - 오류 발생했지만 dirty flag는 사라진다. -> 성공으로 오인할 수 있다.
    - 결과적 위험:  
        - 데이터 손실 또는 디스크 미기록 발생 가능
        - 심지어 탐지도 어렵다. -> 은근히 심각한 손상 발생 가능
        - 테스트 자체도 어려운 경우가 많다.


### Log Semantics

