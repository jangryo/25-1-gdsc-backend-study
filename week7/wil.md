# 고급 백엔드 스터디 7주차

## Chapter 4. Implementing B-Trees

### Rebalancing

단순히 삽입/삭제할 때마다 바로 분할이나 병합을 하지 않고, 최대한 지연시켜 전체적인 트리의 구조 변경 비용을 줄이는 것이 핵심 전략이다.

- Rebalancing with a level: 같은 깊이(레벨)에 있는 노드들끼리 데이터를 나누는 방식이다. 
    - 예: 왼쪽 노드는 90%이상 차 있고, 오른쪽은 30%라면, 데이터를 오른쪽으로 조금 이동시켜 균형을 맞추는 것이다. 

- 이점:
    - 노드 점유율(node occupancy) 향상: 한 노드가 너무 차거나 너무 비는 것을 방지해 공간 낭비를 줄인다.
    - 트리 높이 감소 가능성: 너무 자주 노드를 분할하면 트리의 레벨이 깊어지는데, 이를 지연하면 구조적으로 더 평평한 트리를 유지할 수 있다.

- 단점:
    - 재조정(rebalancing) 유지비용 증가: 노드 간 데이터를 이동시키는 작업이 자주 발생하고 복잡해질 수 있다.

예를 들어 설명하자면, 이 전략은 이삿짐을 바로 정리하지 않고, 공간이 부족해질 때까지 기다렸다가 정리하며 수납 위치를 최적화 하려는 방식과 유사하다. 
분할/병합은 곧 이삿짐 추가 혹은 창고 분할인 셈이다.

- 로드 밸런싱(load balancing): 일반적으로 시스템의 부하를 고르게 분산시키는 개념이지만, 여기서는 트리의 노드들 사이에 데이터를 균형 있게 나누는 작업을 의미한다. 

- 삽입 시 로드 밸런싱:
    - 노드에 공간이 없을 때, 기존 방식은 바로 분할(split).
    - 하지만 여기선 형제 노드에 여유가 있다면, 일부 데이터를 넘겨줘 공간을 확보한다.

- 삭제 시 로드 밸런싱:
    - 노드가 너무 비게 되면, 기존 방식은 병합(merge).
    - 하지만 여기선 형제 노드에 여유가 있다면, 거기서 데이터를 가져와 최소 점유율(보통 50%)를 맞춘다. 

- 공간 활용 향상: 이러한 방식은 트리 구조가 더 균형 있게 유지되며, 불필요한 분할/병합을 줄이고 디스크 I/O도 줄일 수 있다.

형제 노드들 간에 요소를 주고받는 방식으로 균형 조정이 이루어진다. 이러한 최적화는 특히 디스크 기반 B-Tree에서 매우 중요하며, 자주 일어나는 분할/병합 비용을 줄이고 성능을 향상시키는 데 큰 역할을 한다.

- B-Tree의 차별점:
    - 일반 B-Tree는 노드가 가득 차면 바로 분할하여 두 개의 반쯤 찬 노드를 만든다.
    - B*-Tree는 분할을 지연시키고, 이웃 노드로 데이터를 분산시킨다.
        - 그리고 두 노드가 가득 찼을 때, 이들을 세 개의 노드로 분할하며 각 노드를 약 2/3 정도 채우는 방식이다.
    
SQLite는 이 B*-Tree 방식의 구현을 사용하고 있으며, 이는 그만큼 실용성이 높다는 것을 의미한다.

- 장점:
    - 평균 점유율 증가: 디스크나 메모리의 공간 활용이 향상된다.
    - 트리 높이 감소: 같은 수의 요소를 더 적은 레벨로 표현 가능 -> 검색 속도 향상
    - 페이지 접근 수 감소: 디스크 I/O 또는 메모리 접근이 줄어든다.

- 단점:
    - 복잡한 로직 필요: 어떤 형제 노드와 언제 어떻게 분할할 지 관리하는 로직이 복잡해진다.
    - 추가 상태 추적 필요: 각 노드의 점유 상태를 주기적으로 체크하고 반응해야 한다.

그림 4-9는 왼쪽 형제 노드보다 오른쪽 형제 노드가 더 많은 요소를 포함하고 있을 때, 이웃 노드 간에 요소를 분배하는 과정을 보여준다. 더 많이 채워진 노드에서 덜 채워진 노드로 요소들이 이동된다. 

![Figure 4-9](figure4-9.png)

- min/max invariant란?
    - 트리 자료구조에서 각 노드가 관리하는 키의 범위가 일정해야 한다는 불변 조건을 의미한다.
    - 부모 노드의 각 포인터(자식에 대한 참조)는 특정 키 범위(min~max)를 담당한다.
    - 이 범위를 유지함으로써 트리가 검색 가능한 상태를 유지하게 된다.
    - 예를 들어, 부모가 [50], 왼쪽 자식이 [10, 20, 30], 오른쪽 자식이 [60, 70]이라고 하자.
        - 왼쪽 자식은 부모 노드 50보다 작은 값, 오른쪽은 큰 값이다. 이 구조가 min/max invariant이다.
        - 여기서 만약 40을 넣는데, 왼쪽이 너무 가득 차서 40을 오른쪽 자식으로 옮길려고 하면 문제가 생긴다. 50보다 작은 40이 오른쪽으로 가기 때문이다.
            - 이를 해결하려면 부모 노드를 50이 아닌 40으로 업데이트 해야 한다. 
            - 즉, 자식 노드 간에 키를 이동했다면, 부모 노드의 기준 키도 새 범위에 맞게 갱신해야 한다.

노드 간 데이터 이동은 불변 조건을 깨뜨릴 수 있으므로, 부모 노드의 키를 반드시 업데이트해야 한다. 
이것이 바로 트리 전체의 정합성과 검색 정확성을 유지하는 핵심이다.

로드 밸런싱은 데이터베이스 구현에서 사용되는 유용한 기법이다. SQLite는 이 절에서 설명한 내용과 어느정도 유사한 balance-siblings 알고리즘을 구현하고 있다. 로드 밸런싱은 코드에 일부 복잡성을 추가할 수 있지만, 그 사용 사례가 한정적이므로 이후 단계에서 최적화 형태로 구현될 수 있다. 



### Right-Only Appends

- 단조 증가 키(monotonically increasing keys):
    - 예: 1, 2, 3, ...처럼 계속 증가하는 키 값
    - 자동 증가 또는 타임 스태프 기반 키 등이 여기에 해당한다.

- 오른쪽 끝 삽입 최적화:
    - 항상 가장 오른쪽 리프 노드에 삽입되므로 트리 전체를 순회하지 않고 빠르게 위치를 찾을 수 있다.
    - 분할도 오른쪽 끝에서만 주로 일어나므로, 트리의 다른 부분은 비교적 안정적으로 유지된다. 

- 비리프 노드(Non-leaf Node)의 단편화 감소:
    - 삽입 위치가 고정되어 있으므로 중간 노드들의 내용 변경이 적다.
    - 따라서 포인터와 키 값이 잘 유지되고, 디스크 상에서 조각화(fragmentation)가 덜 발생한다. 

- 이 구조의 장점:
    - 빠른 삽입 성능
    - 낮은 유지 비용 (덜한 재조정, 재정렬)
    - 페이지 캐시 효율성 증가: 오른쪽 끝 리프는 자주 접근되므로 캐시에 남아 있을 가능성이 높다. 

이러한 단조 증가 키 기반 설계는 많은 OLTP 시스템에서 쓰이며, 특히 시간 순 로그, ID 기반 테이블 등에서 큰 이점을 제공한다. 

PostgreSQL은 이 경우를 fastpath라고 한다.

- fastpath란?
    - 일반적인 트리 삽입에서는 루트부터 리프까지 경로를 따라 탐색(read path)을 수행한다.
    - 하지만 이 경우에는 탐색을 생략하고 바로 삽입이 가능하므로 매우 빠르게 처리된다. -> 그래서 빠른 경로(fastpath)라고 부른다.
    - 조건 요약:
        1. 삽입 키가 오른쪽 끝 리프의 첫 번째보다 크다 -> 단조 증가 보장
        2. 해당 리프 페이지에 공간이 남아 있다.
        3. 오른쪽 끝 페이지가 캐시에 올라와 있다. -> 디스크 I/O 없다.
    - 성과적 이점:
        - 읽기 경로 건너뛰므로, 루트부터 리프까지 탐색하는 비용이 절감된다. 
        - 캐시 활용: 리프 노드가 자주 쓰이므로 메모리에 이미 올라와 있는 경우가 많다.
        - I/O 감소, 속도 향상

SQLite도 이와 유사한 개념을 갖고 있다. 이를 quickbalance라고 부른다. 

- SQLite의 quickbalance란?
    - PostgreSQL의 fastpath와 유사하지만, 분할 대신 새 페이지 할당 방식을 사용한다.
    - 삽입하려는 키가 가장 큰 값이고, 오른쪽 끝 노드가 가득 찬 경우에 적용된다.

- 기존 방식(일반 분할):
    - 노드가 가득 차면 -> 분할 수행 -> 새 노드 두 개로 나누고 50%씩 데이터 분산

- quickbalance 방식:
    - 분할하지 않고 그냥 새로운 오른쪽 리프 노드를 하나 더 만들어 연결한다.
    - 부모 노드에 새로운 자식 노드 포인터를 추가한다. 

- 장점:
    - 분할에 따른 재조정 없이 빠르게 처리한다.
    - 삽입 키가 계속 커진다는 전제 하에, 새 노드는 금방 채워진다. 
    - 디스크 페이지를 자주 쪼개는 것보다 효율적이다. 

- 단점:
    - 새 페이지는 처음엔 거의 비어 있다. -> 공간 낭비 우려
    - 하지만 데이터 흐름이 오른쪽으로 지속된다면 결국 다시 효율적이게 된다. 

SQLite의 quickbalance는 fastpath와 비슷한 목적(빠른 오른쪽 삽입 처리)을 갖지만, 분할이 아닌 새 페이지 추가라는 점이 핵심 차별점이다. 



#### Bulk Loading

