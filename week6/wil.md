# 고급 백엔드 스터디 6주차

## Implementing B-Trees

### 지난 장 복습

지난 장에서는 바이너리 포맷 구성의 일반 원칙과 셀을 생성하고 계층 구조를 구축하며, 이를 포인터를 사용해 페이지에 연결하는 방법을 배웠다. 나는 이번 주차부터 스터디에 합류하였기 때문에, 이에 대해 간단히 정리해보려고 한다. 

바이너리 포맷 구성의 일반 원칙이란 데이터베이스가 디스크나 메모리에 데이터를 저장할 때 효율성과 일관성, 확장성을 유지하기 위해 사용하는 기본 설계 규칙을 말한다. 이 원칙들은 데이터의 구조적 표현을 정하고, 이후 다양한 저장 구조(B-Tree, LSM-Tree 등)에 적용된다.

- 주요 원칙
    - 셀(Cell) 기반 구성
       - 셀은 데이터의 최소 단위로, 일반적으로 (키, 값) 쌍으로 구성된다.
       - 각 셀은 크기 정보, 키, 값 순서로 바이너리 형태로 저장되며, 고정 또는 가변 길이로 설계될 수 있다.
       - 예시: [KeyLength][Key][ValueLength][Value]
    
    - 계층 구조(Hierachy)
        - 데이터는 셀들의 집합으로 페이지(Page)를 구성하고, 페이지들이 모여 블록이나 노드가 된다. 
        - 이 구조는 나무(Tree) 형태의 인덱스(B-Tree, LSM Tree 등)를 만들 때 쓰이며, 상위 노드는 하위 노드나 페이지를 가리키는 포인터를 포함한다.

    - 포인터 연결(Pointer-based linking)
        - 페이지나 셀 간의 참조 관계는 포인터(실제 주소 또는 오프셋 값)로 연결된다.
        - 이를 통해 검색, 삽입, 삭제 시 필요한 경로 탐색이 빠르게 수행된다.
        - 예: 내부 노드가 리프 페이지를 가리키는 구조

    - 페이지 단위 관리
        - 디스크 접근은 블록(보통 4KB~16KB) 단위로 이루어지므로, 셀은 이 단위 내에서 배치된다. 
        - 페이지에는 일반적으로 헤더(Header)가 있으며, 그 안에:
            - 페이지 타입(리프/내부)
            - 셀 수
            - 여유 공간 오프셋
            - 다음 페이지 포인터 등의 메타데이터가 포함된다.

    - 정렬 vs 비정렬
        - 셀들을 키 기준으로 정렬된 상태로 저장하면 범위 탐색(range query)이 효율적이다.
        - 반대로 비정렬/삽입 순서대로 저장하면, 쓰기 성능이 좋고, 컴팩션 등을 통해 나중에 정렬이 가능하다.
        
    - 고정 길이 vs 가변 길이
        - 고정 길이 포맷은 오프셋 계산이 빠르지만 공간 낭비 가능성이 있다. 
        - 가변 길이 포맷은 공간 효율성이 높지만, 인덱싱이나 파싱이 더 복잡하다.
        실생활 비유:
            - 액셀 파일을 저장한다고 가정하면, 각 셀은 하나의 데이터 항목이고, 한 페이지는 시트의 한 구역이며, 포인터는 셀 간 하이퍼링크처럼 작동한다.

이러한 구성 원칙은 B-Tree나 LSM Tree 같은 복잡한 저장 구조에서도 근간이 된다. 즉, 바이너리 레벨에서 일관되고 예측 가능한 구조를 가지도록 설계함으로써, 다양한 작업(탐색, 삽입, 삭제, 복구 등)이 신뢰성있고 빠르게 수행될 수 있도록 하는 것이다.

### 이번 장의 목표

B-Tree 구조에 특화된 구현 및 최적화 기법을 이해하는 데 초점을 둔다. 

- 이 장의 구성은 세 가지 논리적 그룹으로 나뉜다.
    - 조직화(Organization): 키와 포인터 간의 매핑 및 페이지 간 링크 관리
    - 트리 탐색 과정(Root-to-leaf traversals): 이진 탐색, 부모 노드 추적 등을 다룬다.
    - 최적화 및 유지 관리: 노드 리벨런싱, 대량 데이터 로딩, 가비지 컬렉션 기법

이는 B-Tree 내부 동작을 실제로 구현하거나 분석할 때 필요한 기초적이고 실용적인 구조적 이해를 다지는 데 매우 중요한 구성이다.

## Page Header

### Page Header

- 페이지 헤더: 디스크나 메모리 페이지 상단에 위치하며, 해당 페이지의 메타 정보를 담은 관리용 데이터 구조이다.

- 주요 구성 요소:
    - 플래그(flags): 페이지가 리프인지, 내부 노드인지, 어떤 구조를 사용하는 지 등을 식별
    - 셀 개수: 페이지에 포함된 데이터 셀(레코드)의 수
    - 하단/상단 오프셋: 가용 공간의 위치를 가리켜, 새로운 셀을 어디에 배치할 지 판단하는 데 사용
    - 기타 메타데이터: 페이지 레벨(B-Tree 높이), 레이아웃 버전, 페이지 크기 등

- DBMS별 구현 차이:
    - PostgreSQL: 표준적인 페이지 정보(크기, 버전)
    - MySQL InnoDB: 트리 구조 관련 정보(레벨), 힙 구조 관련 카운트
    - SQLite: 셀 개수 외에도 오른쪽 포인터 포함(B-Tree에서 오른쪽 자식 페이지 연결용)

- 비유: 페이지 헤더는 책의 목차나 장표 상단의 정보란처럼, 해당 내용이 어떤 성격을 가지며 어떻게 읽어야 할 지를 미리 알려주는 요약 정보이다.

페이지 헤더는 탐색 속도 향상, 공간 최적화, 장애 복구 등 다양한 기능의 기초가 되는 필수 구조이다.

### Magic Numbers

- 매직 넘버: 
    - 특정 파일이나 페이지의 시작 부분에 저장된 **고정된 값(식별자)**으로, 해당 구조의 종류, 포맷, 버전 등을 판별하는 데 사용된다.
    - 일반적으로 사람이 알아보기 쉬운 ASCII 코드의 16진 표현을 많이 사용한다. 
        - 예: PAGE -> 50 41 47 45

- 사용 목적: 
    - 유효성 검사(validation): 올바른 구조인지 판단
    - 정합성 확인(sanity check): 파일 또는 페이지의 시작 위치가 잘못 지정되어있는지 확인
    - 포맷 식별: 어떤 종류의 페이지인지 구분

- 실제 동작 예시:
    - 쓰기(write): 페이지 헤더에 PAGE에 해당하는 매직 넘버를 저장
    - 읽기(read): 해당 위치의 4바이트를 읽어서 매직 넘버와 일치하는지 비교

- 비유: 여권 첫 장에 있는 국가 코드 및 사진처럼, 구조물의 정체성을 증명하는 태그 역할

매직 넘버는 특히 시스템 충돌 후 복구, 포맷 자동 식별, 디버깅 등에서 매우 유용한 안전장치이다.

### Sibling Links

- 형제 링크:
    - 트리 구조에서 같은 레벨에 위치한 노드들(형제 노드)을 서로 연결하는 포인터
    - **왼쪽 형제 링크(backward link)**와 **오른쪽 형제 링크(forward link)**로 구성된다.

- 사용 목적:
    - 이웃 노드를 찾을 때 부모 노드를 거치지 않고 직접 이동이 가능하다.
    - 범위 탐색(range scan), 인접 데이터 조회 등에 유리하다.

- 비유:
    - 엘리베이터가 없는 건물에서, 같은 층 방끼리 복도로 연결된 문이 있는 셈
    - 복도가 없으면 계단을 타고 내려갔다가 다시 올라가야 하는 불편함과 유사하다.

- 실용적 장점:
    - 이웃 노드 접근이 빠르다.
    - 트리 탐색 경로의 최적화가 가능하다.

![Figure 4-1](Figure4-1.png)

- 그림 해설
    - (a) 부모 링크를 따라가는 방식
        - 현재 노드의 형제를 찾기 위해 상위 노드(부모 노드)로 역추적 하여,
        - 부모에서 해당 형제를 가리키는 포인터를 찾아 다시 내려온다.
        - 경우에 따라 루트까지 올라갔다가 다시 내려오는 비효율이 발생 가능하다.

    - (b) 형제 링크가 있는 경우
        - 현재 노드의 헤더에 포함된 형제 포인터를 사용해,
        - 바로 오른쪽(또는 왼쪽) 노드로 이동 가능하다.
        - 탐색 비용 최적화 및 빠른 범위 질의가 가능하다.

- 형제 링크 유지의 어려움
    - 노드 A와 노드 B가 형제 링크일 때, A를 분할하거나 병합할 경우, 노드 B의 포인터도 함께 수정해야 일관성이 유지된다.

    - 하지만 B는 분할/병합의 주체가 아닌 외부 노드이기 때문에,
        - 이 노드를 별도로 수정하고 락을 걸어야 한다.
        - 이로 인해 성능 저하나 병목 현상이 생길 수 있다.

    - 동시성 환경에서의 복잡성
        - 여러 스레드가 동시에 트리를 수정할 수 있는 환경에서는
            - 서로 다른 노드에 락을 걸다 충돌하거나
            - 형제 노드를 동시에 수정하려다 데드락(deadlock) 가능성도 있다.
        
        - 따라서 단순한 형제 링크는 병행성 처리에 어려움을 줄 수 있다.

- Blink-Tree에서의 해결
    - Blink-Tree는 이 문제를 해결한 구조이다.
        - 형제 링크를 활용하여 재시도 없이 낙관적 접근(optimistic concurrency) 가능
        - 락 없이도 정합성 유지
        - 성능과 병행성 모두를 만족시킨다.

### Rightmost Pointer

- 구분 키(seperator key)
    - 노드 내에서 키 값의 범위를 구분해주는 키
    - 각 키는 어떤 구간의 값을 어떤 자식 노드로 보낼 지 결정한다.

**Counting Keys**에서 언급된 **+1의 의미**: 예를 들어, 노드에 K1, K2, K3라는 키가 있을 때 이 구분 키들이 만드는 구간은 4개이다. 따라서 키가 3개이면 자식 포인터는 4개가 필요하다. 이것이 +1이다. 항상 자식 포인터는 키 수 + 1만큼 필요하다.

- 구분 키의 불변 조건(seperator key invariants)
    - 각 구분 키는 값의 범위를 나누는 기준 점으로 사용된다.
    - 각 구분 키는 왼쪽 구간에 해당하는 자식 노드를 가리키는 포인터와 함께 존재해야 한다. 
    - 예를 들어, 키 K1은 값 < K1의 범위를 P0 포인터로 연결하는 기준 역할이다.

![Figure4-2](Figure4-2.png)

위 그림 4-2를 보면 키 K1, K2, K3는 각 키 앞에 하나씩 포인터가 존재한다.(P0, P1, P2)
하지만 마지막 포인터 P3은 K3 이상의 범위를 위해 필요하지만, 직접 연결된 키가 없다. 
따라서 이 **오른쪽 끝 포인터(rightmost pointer)**는 별도로 저장한다.

- 추가 포인터의 저장 위치
    - 일반적인 키-포인터 쌍으로 저장하기 어려운 오른쪽 끝 포인터는,
    - **페이지 헤더(header)**에 따로 저장하는 구현이 많다. SQLite도 이 방식을 사용한다.

오른쪽 자식 노드가 분할되고, 새로운 셀이 부모 노드에 추가된다면, **오른쪽 자식 포인터는 다시 지정**되어야 한다. 그림 4-3을 보면, 분할 이후 부모 노드에 추가된 셀(회색으로 표시)은 **승격된 키(promoted key)**를 포함하고, 분할된 기존 노드를 가리킨다. 이전의 오른쪽 포인터 대신, 새롭게 생성된 노드를 가리키는 포인터가 할당된다. SQLite에서도 설명되고 구현되어 있다.

![Figure4-3](Figure4-3.png)

- 그림 4-3 설명
    - Before Split:
        - 하위 노드(자식 노드)가 데이터로 가득 찼다(K3, K4, K5).
        - 이 자식 노드를 두 개로 분할 작업을 하려는 상태

    - After Split:
        - 노드가 꽉 차있는데 K6을 추가하려고 하면 들어갈 공간이 없다.
        - 이 경우 노드를 반으로 나눠야 한다. -> 분할(Split)
        - 중간 키(K4)가 부모 노드로 승격(promoted)된다.
        - 기존 노드는 왼쪽 절반만 유지하고, 나머지 키들은 새로운 오른쪽 노드로 이동한다. 
        - 이제 부모 노드는 K3, K4라는 키를 가지고 있다. 

### Node High Keys

일반적인 B-Tree에서는 rightmost pointer가 페이지 헤더 등 노드 바깥에 따로 저장된다. 
하지만, 이 문단에서는 포인터와 high key를 한 셀안에 묶어서 저장한다. 

- High Key란?
    - 한 노드가 자식 노드를 가리킬 때, **그 자식 아래에 존재할 수 있는 값의 최대치**를 함께 표시해주는 키이다.
    - 예를 들어, 어떤 자식 노드가 [40,50] 값을 가진다면, 부모 셀에 High Key = 50 같은 식으로 명시한다.

이 방식은 PostgreSQL에서 사용되며, 이를 Blink-Tree라고 부른다.

B-Tree는 N개의 키(Ki)와 N+1개의 포인터(Pi)를 갖는다. 각 하위 트리에서 키들은 Ki-1 ≤ Ks < Ki의 범위로 제한된다. 이 때, **K0 = −∞**는 암묵적으로 존재하며, 노드에는 실제로 저장되지 않는다.

- **K0 = −∞**가 암묵적인 이유:
    - 트리의 가장 왼쪽 경계값은 모든 값보다 작은 가상의 값으로 취급한다.
    - 그래서 실제 노드에 K0이라는 값은 존재하지 않는다. 
    - 하지만 탐색 규칙을 명확히 표현하기 위해 수학적으로 표기해둔 것이다.

Blink-Tree는 각 노드에 KN+1 키를 추가한다. 이 키는 포인터 **PN이 가리키는 하위 트리**에 저장될 수 있는 키들의 상한선을 지정하며, 현재 하위 트리에 저장될 수 있는 값들의 상한선이 된다. 그림 4-4의 (a)는 high key가 없는 노드, (b)는 high key를 포함한 노드를 나타낸다.

![Figure 4-4](Figure4-4.png)

- high key 사용 이유:
    - 트리 탐색 중, 어떤 키가 PN 포인터 범위 안에 포함되는지 아닌지를 판단하기 위함이다.
    - 특히 동시성 환경에서 누군가가 데이터를 옮기거나 분할하는 중일 때, 탐색이 오른쪽 노드로 안전하게 넘어갈 수 있는지 판단하는 기준점이 필요하다. 
    - 예를 들어, [20 | 50]이라는 기존 B-Tree에서 P2는 50보다 큰 값들을 담당하지만, 정확히 어디까지 커도 되는 지 모른다. 하지만 [20 | 50 | **90**]이면 50~90사이만 이 노드가 책임진다는 것을 명시할 수 있다.

이 경우 포인터는 **쌍(pairwise)**으로 저장될 수 있으며, 각 셀이 하나의 대응되는 포인터를 가질 수 있다. 이로 인해 rightmost pointer 처리가 더 단순해질 수 있는데, 이는 고려해야 할 예외적인 상황(edge case)가 줄어들기 때문이다. 

- 쌍으로 지정된 포인터란?
    - 기존에는 [K1, K2, K3] 키, [P0, P1, P2, P3] 포인터 (+1)
    - 이 방식에서는 각 셀마다 키 + 포인터 쌍으로 저장한다.
        - [K1|P1], [K2|P2], [K3|P3] + high key
        - 마지막에 별도 rightmost pointer가 필요 없거나 단순 처리가 가능하다. 
        - 포인터와 셀이 1:1 대응하므로 구현이 쉽다. 

그림 4-5에서는 두 가지 방식의 **페이지 구조 개요도**를 볼 수 있다. 이들이 어떻게 **탐색 공간**을 다르게 분할하는 지도 확인할 수 있다.
- 첫 번째 방식은 +∞까지 올라간다.
- 두 번째 방식은 K3의 상한(upper bound)까지만 올라간다.
![Figure 4-5](Figure4-5.png)

### Overflow Pages

- Node Size: 한 노드(= 한 페이지)의 최대 크기 (예: 4KB)
- Fanout: 한 노드가 가질 수 있는 자식 노드 수(보통 키 수 + 1)
-> 이 값들은 고정되어 있어서, 트리 구성 중 유연하게 조정되지 않는다.

- 문제점:
    - 너무 큰 값이 들어오면
        - 셀 하나가 너무 커진다 -> 페이지에 몇개 못들어간다.
        - 예: 각 셀이 2KB이면 4KB 페이지에 딱 2개만 저장 가능
    - 너무 작은 값이 들어오면
        - 셀들이 너무 작으면 페이지 구조 상 빈 공간이 남는다.
        - 예: 10바이트짜리 셀이 200개 들어갈 수 있지만 구조상 100개만 들어간다.

고정된 노드 크기/포맷은 다양한 값 크기에 대응하기 어렵다. 그래서 너무 큰 값은 페이지에서 분리해서 따로 저장하는 방식이 필요하다. 이것이 바로 Overflow Pages의 개념이다.

- B-Tree의 전제 조건
    - 노드는 항목 개수 기준으로 꽉 찼는 지를 판단한다. (예: 4개 이상이면 분할)
    - 하지만 현실에선 각 항목(셀)의 실제 크기가 다를 수 있다.

이때문에 노드에 들어간 항목 수는 기준보다 적어서 분할 조건이 아닌데, 페이지는 실제 저장 공간 부족으로 저장이 불가할 수 있다.
즉, 논리적으로는 **비어있지만**, 물리적으로는 **꽉 차있다**.

위 문제는 해결이 어렵다. 페이지는 보통 4KB, 8KB와 같은 고정 크기 블록이다. 이를 키우려면 새 페이지 할당, 기존 데이터 복사, 메타데이터 수정 등이 필요한데, 이는 매우 번거롭고 성능 저하를 초래할 수 있다.

이때 필요한 게 바로 **오버플로우 페이지**이다. 
기존 페이지가 꽉 찼을 때, 큰 값을 다른 페이지에 따로 저장하고, 원래 자리에는 포인터만 남겨두는 방식이다. 



## Bianry Search



## Propagating Splits and Merges