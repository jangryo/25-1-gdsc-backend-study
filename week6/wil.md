# 고급 백엔드 스터디 6주차

## Implementing B-Trees

### 지난 장 복습

지난 장에서는 바이너리 포맷 구성의 일반 원칙과 셀을 생성하고 계층 구조를 구축하며, 이를 포인터를 사용해 페이지에 연결하는 방법을 배웠다. 나는 이번 주차부터 스터디에 합류하였기 때문에, 이에 대해 간단히 정리해보려고 한다. 

바이너리 포맷 구성의 일반 원칙이란 데이터베이스가 디스크나 메모리에 데이터를 저장할 때 효율성과 일관성, 확장성을 유지하기 위해 사용하는 기본 설계 규칙을 말한다. 이 원칙들은 데이터의 구조적 표현을 정하고, 이후 다양한 저장 구조(B-Tree, LSM-Tree 등)에 적용된다.

- 주요 원칙
    - 셀(Cell) 기반 구성
       - 셀은 데이터의 최소 단위로, 일반적으로 (키, 값) 쌍으로 구성된다.
       - 각 셀은 크기 정보, 키, 값 순서로 바이너리 형태로 저장되며, 고정 또는 가변 길이로 설계될 수 있다.
       - 예시: [KeyLength][Key][ValueLength][Value]
    
    - 계층 구조(Hierachy)
        - 데이터는 셀들의 집합으로 페이지(Page)를 구성하고, 페이지들이 모여 블록이나 노드가 된다. 
        - 이 구조는 나무(Tree) 형태의 인덱스(B-Tree, LSM Tree 등)를 만들 때 쓰이며, 상위 노드는 하위 노드나 페이지를 가리키는 포인터를 포함한다.

    - 포인터 연결(Pointer-based linking)
        - 페이지나 셀 간의 참조 관계는 포인터(실제 주소 또는 오프셋 값)로 연결된다.
        - 이를 통해 검색, 삽입, 삭제 시 필요한 경로 탐색이 빠르게 수행된다.
        - 예: 내부 노드가 리프 페이지를 가리키는 구조

    - 페이지 단위 관리
        - 디스크 접근은 블록(보통 4KB~16KB) 단위로 이루어지므로, 셀은 이 단위 내에서 배치된다. 
        - 페이지에는 일반적으로 헤더(Header)가 있으며, 그 안에:
            - 페이지 타입(리프/내부)
            - 셀 수
            - 여유 공간 오프셋
            - 다음 페이지 포인터 등의 메타데이터가 포함된다.

    - 정렬 vs 비정렬
        - 셀들을 키 기준으로 정렬된 상태로 저장하면 범위 탐색(range query)이 효율적이다.
        - 반대로 비정렬/삽입 순서대로 저장하면, 쓰기 성능이 좋고, 컴팩션 등을 통해 나중에 정렬이 가능하다.
        
    - 고정 길이 vs 가변 길이
        - 고정 길이 포맷은 오프셋 계산이 빠르지만 공간 낭비 가능성이 있다. 
        - 가변 길이 포맷은 공간 효율성이 높지만, 인덱싱이나 파싱이 더 복잡하다.
        실생활 비유:
            - 액셀 파일을 저장한다고 가정하면, 각 셀은 하나의 데이터 항목이고, 한 페이지는 시트의 한 구역이며, 포인터는 셀 간 하이퍼링크처럼 작동한다.

이러한 구성 원칙은 B-Tree나 LSM Tree 같은 복잡한 저장 구조에서도 근간이 된다. 즉, 바이너리 레벨에서 일관되고 예측 가능한 구조를 가지도록 설계함으로써, 다양한 작업(탐색, 삽입, 삭제, 복구 등)이 신뢰성있고 빠르게 수행될 수 있도록 하는 것이다.

### 이번 장의 목표

B-Tree 구조에 특화된 구현 및 최적화 기법을 이해하는 데 초점을 둔다. 

- 이 장의 구성은 세 가지 논리적 그룹으로 나뉜다.
    - 조직화(Organization): 키와 포인터 간의 매핑 및 페이지 간 링크 관리
    - 트리 탐색 과정(Root-to-leaf traversals): 이진 탐색, 부모 노드 추적 등을 다룬다.
    - 최적화 및 유지 관리: 노드 리벨런싱, 대량 데이터 로딩, 가비지 컬렉션 기법

이는 B-Tree 내부 동작을 실제로 구현하거나 분석할 때 필요한 기초적이고 실용적인 구조적 이해를 다지는 데 매우 중요한 구성이다.

## Page Header

### Page Header

- 페이지 헤더: 디스크나 메모리 페이지 상단에 위치하며, 해당 페이지의 메타 정보를 담은 관리용 데이터 구조이다.

- 주요 구성 요소:
    - 플래그(flags): 페이지가 리프인지, 내부 노드인지, 어떤 구조를 사용하는 지 등을 식별
    - 셀 개수: 페이지에 포함된 데이터 셀(레코드)의 수
    - 하단/상단 오프셋: 가용 공간의 위치를 가리켜, 새로운 셀을 어디에 배치할 지 판단하는 데 사용
    - 기타 메타데이터: 페이지 레벨(B-Tree 높이), 레이아웃 버전, 페이지 크기 등

- DBMS별 구현 차이:
    - PostgreSQL: 표준적인 페이지 정보(크기, 버전)
    - MySQL InnoDB: 트리 구조 관련 정보(레벨), 힙 구조 관련 카운트
    - SQLite: 셀 개수 외에도 오른쪽 포인터 포함(B-Tree에서 오른쪽 자식 페이지 연결용)

- 비유: 페이지 헤더는 책의 목차나 장표 상단의 정보란처럼, 해당 내용이 어떤 성격을 가지며 어떻게 읽어야 할 지를 미리 알려주는 요약 정보이다.

페이지 헤더는 탐색 속도 향상, 공간 최적화, 장애 복구 등 다양한 기능의 기초가 되는 필수 구조이다.

### Magic Numbers

- 매직 넘버: 
    - 특정 파일이나 페이지의 시작 부분에 저장된 **고정된 값(식별자)**으로, 해당 구조의 종류, 포맷, 버전 등을 판별하는 데 사용된다.
    - 일반적으로 사람이 알아보기 쉬운 ASCII 코드의 16진 표현을 많이 사용한다. 
        - 예: PAGE -> 50 41 47 45

- 사용 목적: 
    - 유효성 검사(validation): 올바른 구조인지 판단
    - 정합성 확인(sanity check): 파일 또는 페이지의 시작 위치가 잘못 지정되어있는지 확인
    - 포맷 식별: 어떤 종류의 페이지인지 구분

- 실제 동작 예시:
    - 쓰기(write): 페이지 헤더에 PAGE에 해당하는 매직 넘버를 저장
    - 읽기(read): 해당 위치의 4바이트를 읽어서 매직 넘버와 일치하는지 비교

- 비유: 여권 첫 장에 있는 국가 코드 및 사진처럼, 구조물의 정체성을 증명하는 태그 역할

매직 넘버는 특히 시스템 충돌 후 복구, 포맷 자동 식별, 디버깅 등에서 매우 유용한 안전장치이다.

### Sibling Links

- 형제 링크:
    - 트리 구조에서 같은 레벨에 위치한 노드들(형제 노드)을 서로 연결하는 포인터
    - **왼쪽 형제 링크(backward link)**와 **오른쪽 형제 링크(forward link)**로 구성된다.

- 사용 목적:
    - 이웃 노드를 찾을 때 부모 노드를 거치지 않고 직접 이동이 가능하다.
    - 범위 탐색(range scan), 인접 데이터 조회 등에 유리하다.

- 비유:
    - 엘리베이터가 없는 건물에서, 같은 층 방끼리 복도로 연결된 문이 있는 셈
    - 복도가 없으면 계단을 타고 내려갔다가 다시 올라가야 하는 불편함과 유사하다.

- 실용적 장점:
    - 이웃 노드 접근이 빠르다.
    - 트리 탐색 경로의 최적화가 가능하다.

![Figure 4-1](Figure4-1.png)

- 그림 해설
    - (a) 부모 링크를 따라가는 방식
        - 현재 노드의 형제를 찾기 위해 상위 노드(부모 노드)로 역추적 하여,
        - 부모에서 해당 형제를 가리키는 포인터를 찾아 다시 내려온다.
        - 경우에 따라 루트까지 올라갔다가 다시 내려오는 비효율이 발생 가능하다.

    - (b) 형제 링크가 있는 경우
        - 현재 노드의 헤더에 포함된 형제 포인터를 사용해,
        - 바로 오른쪽(또는 왼쪽) 노드로 이동 가능하다.
        - 탐색 비용 최적화 및 빠른 범위 질의가 가능하다.

- 형제 링크 유지의 어려움
    - 노드 A와 노드 B가 형제 링크일 때, A를 분할하거나 병합할 경우, 노드 B의 포인터도 함께 수정해야 일관성이 유지된다.

    - 하지만 B는 분할/병합의 주체가 아닌 외부 노드이기 때문에,
        - 이 노드를 별도로 수정하고 락을 걸어야 한다.
        - 이로 인해 성능 저하나 병목 현상이 생길 수 있다.

    - 동시성 환경에서의 복잡성
        - 여러 스레드가 동시에 트리를 수정할 수 있는 환경에서는
            - 서로 다른 노드에 락을 걸다 충돌하거나
            - 형제 노드를 동시에 수정하려다 데드락(deadlock) 가능성도 있다.
        
        - 따라서 단순한 형제 링크는 병행성 처리에 어려움을 줄 수 있다.

- Blink-Tree에서의 해결
    - Blink-Tree는 이 문제를 해결한 구조이다.
        - 형제 링크를 활용하여 재시도 없이 낙관적 접근(optimistic concurrency) 가능
        - 락 없이도 정합성 유지
        - 성능과 병행성 모두를 만족시킨다.

###

## Bianry Search



## Propagating Splits and Merges