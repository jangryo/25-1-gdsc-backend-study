# 고급 백엔드 스터디 8주차

# Chapter 5. Transaction Processing and Recovery

이 책에서는 데이터베이스 시스템 개념을 하향식이 아닌 상향식 접근 방식으로 다뤄왔다.
저장 구조(storage structures)에 대해 배웠고, 버퍼 관리(buffer management), 락 관리(lock management), 복구(recovery)와 같은 상위 컴포넌트를 배울 준비가 됐다.

- 트랜잭션(Transaction):
    - 데이터베이스 관리 시스템에서 더 이상 나눌 수 없는 논리적 작업 단위
    - 여러 연산을 하나의 단계로 표현
    - 논리적 작업 단위 묶음
    - 예: 계좌 이체 -> 출금 + 입금 = 한 트랜잭션
    - 트랜잭션의 목적:
        - 여러 작업을 하나처럼 처리해서 데이터 정합성과 안정성을 보장

데이터베이스 트랜잭션은 ACID를 보장해야 한다.

- ACID 속성:
    1. Atomicity(원자성):
        - 트랜잭션 내의 모든 연산은 반드시 모두 성공하거나, 모두 실패해야 한다. 부분적으로 적용되서는 안된다.
        - 각각의 트랜잭션은 커밋(commit) 하여 실행 중 이루어진 모든 쓰기 연산의 변경 사항을 외부에 보이도록 만들거나, 중단(abort) 하여 아직 외부에 노출되지 않은 모든 부작용을 롤백(되돌림)할 수 있다.
        - 커밋은 최종 연산이다. 중단된 트랜잭션은 재시도될 수 있다.
    2. Consistency(일관성): 
        - 트랜잭션 전후로 DB의 상태가 유효해야 한다.
        - 애플리케이션에 특화된 보장으로, 하나의 트랜잭션은 데이터베이스를 하나의 유효한 상태에서 다른 유효한 상태로만 전이시켜야 한다.
        - 제약조건, 참조 무결성 등의 데이터베이스 불변식을 항상 유지해야 한다. 
        - 일관성은 ACID 속성 중 가장 약하게 정의된 특성이며, 이는 데이터베이스 자체가 아니라 사용자가 제어하는 요소이기 때문이다.
    3. Isolation(고립성):
        - 동시에 실행되는 트랜잭션끼리 서로 간섭하지 않는다.
        - 고립성은 변경 사항이 언제 보이게 되는지, 그리고 어떤 변경이 다른 트랜잭션에 보일 수 있는지를 정의한다.
        - 많은 DB는 성능 상의 이유로 이 정의보다 약한 격리 수준을 사용한다. 
        - 어떤 동시성 제어 방식이 사용되는 지에 따라, 하나의 트랜잭션이 수행한 변경 사항이 다른 트랜잭션에 보일 수도 있고, 아닐 수도 있다. 
    4. Durability(지속성):
        - 일단 커밋된 트랜잭션은 디스크에 영구히 보존되어야 한다.
        - 정전, 시스템 오류, 장애 발생 이후에도 유지되어야 한다.

디스크에 데이터를 조직화하고 영구적으로 저장하는 저장 구조 외에도, 데이터베이스 시스템에서 트랜잭션을 구현하려면 여러 구성 요소들이 함께 작동해야 한다. 노드 내에서는 트랜잭션 관리자(transaction manager)가 트랜잭션과 그 개별 단계들을 조정하고, 스케줄링하며, 추적하는 역할을 수행한다. 

- 락 관리자(lock manager)의 역할:
    - 데이터 무결성 보장: 동시에 여러 트랜잭션이 같은 데이터를 수정하려는 경우 충돌 방지
    - 접근 제어: 누가 어떤 자원에 접근할 수 있는 지를 제어

- 락 종류:
    - 공유 락(shared lock): 여러 트랜잭션이 동시에 읽기 가능
    - 전용 락(exclusive lock): 한 트랜잭션이 읽기/쓰기 가능

- 락 요청 처리 과정:
    1. 트랜잭션이 락 요청
    2. 락 관리자가 현재 보유 상태를 확인
    3. 충돌 없으면 즉시 허용, 충돌 시 대기 or 중단 후 재시도

- 락 해제 시 동작:
    - 락이 해제되었거나 트랜잭션이 종료되면,
    - 대기열에 있는 다음 트랜잭션에게 락을 부여하고 알린다.

- **페이지 캐시(page cache)**란?
    - 디스크에서 데이터를 직접 읽고 쓰는 대신, 메모리에 임시로 저장하여 빠르게 접근할 수 있게 해주는 중간 계층 캐시
    - 주요 기능:
        1. 변경 사항 임시 보관: 트랜잭션이 데이터를 수정하면, 디스크에 바로 쓰지 않고 캐시 페이지에 먼저 반영
        2. 성능 향상: 메모리 접근은 디스크보다 훨씬 빠르므로, 읽기/쓰기 성능 대폭 개선
        3. 비동기적 디스크 반영: 일정 시점에만 디스크로 동기화 -> 효율적으로 디스크 I/O 가능
        - 동기화되지 않은 상태란?
            - 페이지는 메모리에서 최신 상태지만, 디스크에는 아직 반영이 안된 상태이다.
            - 이때 장애 발생하면 손실 위험이 있으므로 -> 복구 로그(WAL 등)와 함께 사용한다. 

- 로그 관리자(log manager):
    - 변경 이력 기록자: 디스크에 쓰기 전, 캐시에 적용된 변경 내용을 먼저 로그에 기록한다.
    - 이를 통해 충돌(crash) 후에도 데이터 복구 가능

- 로그의 두 가지 용도:
    1. REDO: 시스템 재시작 시 로그를 읽어 최근 변경을 다시 적용
    2. UNDO: 중단(abort)된 트랜잭션의 변경 사항은 되돌리기

- 왜 로그가 먼저 쓰여야 할까?
    - 변경 사항을 디스크에 반영하기 전에 로그로 기록해두면,
    - 충돌 후에도 정확한 상태 복원 가능
    - 이를 WAL(Write-Ahead Logging)이라고 한다.

로그 관리는 데이터베이스의 신뢰성과 복구 가능성을 위한 핵심 장치로, 아직 디스크에 반영되지 않은 상태에서도 변경 사항의 복구와 취소를 가능하게 한다.